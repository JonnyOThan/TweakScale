// TODO: naming conventions are all over the place in here.  let's use tweakscale_ as a prefix but then pascal case the rest?  Should it be tweakScale_ ?  

// A note about MM passes:
// TweakScale is installed in the TweakScale directory, but the dll is named Scale.dll.  So both of these names exist as passes and mod identifiers
// There are various mods out there that use either one of these.  So we will use FOR[TweakScale] because 
// 1) that's the canonical name of the mod and
// 2) it comes after Scale, so any other mod's patches in the before/after Scale pass will go first (I don't think TweakScale has ever used FOR[Scale] but I should check)
// as a general philosophy, TweakScale's patches should:
//     apply to parts that don't already have tweakscale modules
//     run AFTER most other mods set up their tweakscale configs
//     set defaults or apply any hints
//     not run so late that they can't then be modified (i.e. no LAST or FINAL)
// So, if the other mods are using the legacy pass, BEFORE[Scale], AFTER[Scale], or BEFORE[TweakScale] they will go before FOR[TweakScale].
// in general I would suggest using BEFORE[TweakScale] if you want to provide tweakscale support for your own mod.  
// This has the double benefit of not requiring a NEEDS marker - the BEFORE[TweakScale] pass will not be executed if TweakScale isn't installed.

// ----- AllTweak

// TweakScaleRescaled will add scaling support to every part that isn't marked tweakscale_ignore, making AllTweak mostly obsolete.
// AllTweak might still be useful to people because it doesn't care about tweakscale_ignore
// But it also uses type = stack without setting the default (so it defaults to 1.25m)
// Our logic below does a better job of finding defaults for parts
// At the risk of being a bad neighbor, let's provide a better version of the alltweak patch if it's installed
// The nice thing about this though is that it runs early enough (not in FINAL or LAST) that other mods can customize the behavior after the fact (e.g. re-adding the tweakscale_ignore marker)
@PART:HAS[#tweakscale_ignore]:NEEDS[AllTweak]:FOR[TweakScale]
{
	!tweakscale_ignore =
}

// ----- tweakscale_ignore disabled?

// I'm a bit hesitant about supporting this, since the "false" is case sensitive and I don't really want to specify all possible capitalizations here.
@PART:HAS[#tweakscale_ignore[false]]:FOR[TweakScale]
{
	!tweakscale_ignore = 
}

// ----- NODE SIZE: try to determine the default radius of the part (if the tweakscale module doesn't already have a defaultScale - no need to inflate patch count)

// anything with size1p5 in bulkheadProfiles gets tweakscale_node_size = 1.5, since this can't be detected with attachNode sizes (they are integers)
@PART:HAS[~tweakscale_ignore&!MODULE[TweakScale]:HAS[#defaultScale]&~tweakscale_node_size&#bulkheadProfiles[*size1p5*]]:FOR[TweakScale]
{
	tweakscale_node_size = 1.5
}

// otherwise anything with a node_stack_top or node_stack_bottom gets its size set
@PART:HAS[~tweakscale_ignore&!MODULE[TweakScale]:HAS[#defaultScale]&~tweakscale_node_size&#node_stack_top]:FOR[TweakScale]
{
	// The 7th value is the node size
	// WARNING: sometimes these nodes are defined with only 6 values (omitting the size parameter, which will default to 1 from code)
	// if that happens, this is going to silently fetch the 6th value instead.  It will likely not be an integer (but it might be!)
	// and it might not match the known node sizes below, causing a MM patching error when we don't end up with a tweakscale_default_scale field
	// the right fix is PROBABLY to just provide a patch for specific affected parts (stock liquidEngine_v2 being one)
	// if we had a way to check the length of the value list that would be handy...
	// might be possible to try to write a default value to the 7th position using &node_stack_top[6] = 1 ?  needs testing.
	tweakscale_node_size = #$node_stack_top[6]$
}

@PART:HAS[~tweakscale_ignore&!MODULE[TweakScale]:HAS[#defaultScale]&~tweakscale_node_size&#node_stack_bottom]:FOR[TweakScale]
{
	// see warning above
	tweakscale_node_size = #$node_stack_bottom[6]$
}

// ----- ENGINES

// SRBs
@PART:HAS[~tweakscale_ignore&!MODULE[TweakScale]&@MODULE[ModuleEngines*]:HAS[@PROPELLANT[SolidFuel]]]:FOR[TweakScale]
{
	#@TWEAKSCALEBEHAVIOR[SRB]/MODULE[TweakScale] { }
}

// other engines
@PART:HAS[~tweakscale_ignore&!MODULE[TweakScale]&@MODULE[ModuleEngines*]]:FOR[TweakScale]
{
	#@TWEAKSCALEBEHAVIOR[Engine]/MODULE[TweakScale] { }
}

// ---- WINGS

// wings without resources get free_square
@PART:HAS[~tweakscale_ignore&!MODULE[TweakScale]&@MODULE[ModuleLiftingSurface]&!RESOURCES]:FOR[TweakScale]
{
	%MODULE[TweakScale]
	{
		type = free_square
	}
}

// wings *with* resources are normal free scale - TODO: figure out if free_square actually works correctly with resources
@PART:HAS[~tweakscale_ignore&!MODULE[TweakScale]&@MODULE[ModuleLiftingSurface]&@RESOURCES]:FOR[TweakScale]
{
	%MODULE[TweakScale]
	{
		type = free
	}
}

@PART:HAS[~tweakscale_ignore&!MODULE[TweakScale]&@MODULE[ModuleAeroSurface]&@RESOURCES]:FOR[TweakScale]
{
	%MODULE[TweakScale]
	{
		type = free_square
	}
}

// ---- CONTROL SURFACES

@PART:HAS[~tweakscale_ignore&!MODULE[TweakScale]&@MODULE[ModuleControlSurface]]:FOR[TweakScale]
{
	%MODULE[TweakScale]
	{
		type = free_square
	}
}

// ---- ANTENNAS

@PART:HAS[~tweakscale_ignore&!MODULE[TweakScale]&@MODULE[ModuleDataTransmitter]:HAS[~antennaType[INTERNAL]]]:FOR[TweakScale]
{
	%MODULE[TweakScale]
	{
		type = free_square
	}
}

@PART:HAS[~tweakscale_ignore&!MODULE[TweakScale]&@MODULE[ModuleDeployableAntenna]]:FOR[TweakScale]
{
	%MODULE[TweakScale]
	{
		type = free_square
	}
}

// ----- SOLAR PANELS

@PART:HAS[~tweakscale_ignore&!MODULE[TweakScale]&@MODULE[ModuleDeployableSolarPanel]]:FOR[TweakScale]
{
	%MODULE[TweakScale]
	{
		type = free_square
	}
}

// ----- WHEELS

@PART:HAS[~tweakscale_ignore&!MODULE[TweakScale]&@MODULE[ModuleWheelBase]]:FOR[TweakScale]
{
	%MODULE[TweakScale]
	{
		type = free
	}
}

// ----- DECOUPLERS

@PART:HAS[~tweakscale_ignore&!MODULE[TweakScale]&@MODULE[ModuleDecouple]]:FOR[TweakScale]
{
	#@TWEAKSCALEBEHAVIOR[Decoupler]/MODULE[TweakScale] { }
}

@PART:HAS[~tweakscale_ignore&!MODULE[TweakScale]&@MODULE[ModuleAnchoredDecoupler]]:FOR[TweakScale]
{
	#@TWEAKSCALEBEHAVIOR[Decoupler]/MODULE[TweakScale] { }
}

// ----- MECHANISMS below here

// strip whitespace from tweakscale_node_size
@PART:HAS[#tweakscale_node_size]:FOR[TweakScale]
{
	@tweakscale_node_size ^= :\s+::
}

// convert node size to default scale

@PART:HAS[~tweakscale_default_scale&#tweakscale_node_size[0]]:FOR[TweakScale]
{
	tweakscale_default_scale = 0.625
}

@PART:HAS[~tweakscale_default_scale&#tweakscale_node_size[1]]:FOR[TweakScale]
{
	tweakscale_default_scale = 1.25
}

@PART:HAS[~tweakscale_default_scale&#tweakscale_node_size[1.5]]:FOR[TweakScale]
{
	tweakscale_default_scale = 1.875
}

@PART:HAS[~tweakscale_default_scale&#tweakscale_node_size[2]]:FOR[TweakScale]
{
	tweakscale_default_scale = 2.5
}

@PART:HAS[~tweakscale_default_scale&#tweakscale_node_size[3]]:FOR[TweakScale]
{
	tweakscale_default_scale = 3.75
}

@PART:HAS[~tweakscale_default_scale&#tweakscale_node_size[4]]:FOR[TweakScale]
{
	tweakscale_default_scale = 5
}

// set the scale type to stack for anything with with tweakscale_node_size and tweakscale_default_scale and doesn't already have the type set
@PART:HAS[~tweakscale_ignored&#tweakscale_node_size&#tweakscale_default_scale&@MODULE[TweakScale]:HAS[~type]]:FOR[TweakScale]
{
	@MODULE[TweakScale]
	{
		type = stack
		%defaultScale = #$/tweakscale_default_scale$
	}
}

// otherwise set the scale type to free if it's missing
@PART:HAS[~tweakscale_ignored&@MODULE[TweakScale]:HAS[~type]]:FOR[TweakScale]
{
	@MODULE[TweakScale]
	{
		type = free
	}
}

// ----- Final backstops - things that don't have the module

// add a free-scale module to anything that doesn't have one
// I keep going back and forth about whether this should check for a tweakscale_node_size field and use stack scaling in that case
// I think there's probably a lot of parts that have a node_top but shouldn't be stack scaled, like structural parts.
// it will probably be easier to apply defaults to the things that SHOULD be stack scaled like fuel tanks, and just leave the backstop as free scale.
// It's far worse for something to be marked as stack scale when it isn't than for something that should be stack scaled to be marked as free.
@PART:HAS[~tweakscale_ignore&!MODULE[TweakScale]]:LAST[TweakScale]
{
	MODULE
	{
		name = TweakScale
		type = free
	}
}

// ----- cleanup

// These values are useful for debugging in the modulemanager.configcache, but they cause warnings in the log on loading, e.g.
// [WRN 03:28:29.527] PartLoader Warning: Variable tweakscale_ignore not found in Part
// TODO: need to figure out what to do with them (maybe move them into the tweakscale module or a TWEAKSCALE_DEBUG node or something)
// also not too crazy about adding a patch for every part, but adding all the necessary :HAS filters would be pretty tedious)
@PART:LAST[TweakScale]:NEEDS[disabled]
{
	-tweakscale_ignore = 
	-tweakscale_default_scale = 
	-tweakscale_node_size = 
}
